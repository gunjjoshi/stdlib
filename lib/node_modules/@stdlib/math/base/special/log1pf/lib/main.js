/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/12.2.0/lib/msun/src/s_log1pff.c?revision=367086&view=markup}. The implementation follows the original, but has been modified for JavaScript.
*
* ```text
* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc. business.
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ```
*/

'use strict';

// MODULES //

var FLOAT32_NINF = require( '@stdlib/constants/float32/ninf' );
var FLOAT32_ABS_MASK = require( '@stdlib/constants/float32/abs-mask' );
var FLOAT32_PRECISION = require( '@stdlib/constants/float32/precision' );
var FLOAT32_EXPONENT_BIAS = require( '@stdlib/constants/float32/exponent-bias' );
var FLOAT32_SIGNIFICAND_MASK = require( '@stdlib/constants/float32/significand-mask' );
var toWord = require( '@stdlib/number/float32/base/to-word' );
var fromWord = require( '@stdlib/number/float32/base/from-word' );
var float64ToFloat32 = require( '@stdlib/number/float64/base/to-float32' );
var polyval = require( './polyval_lp.js' );


// VARIABLES //

// High and low words of ln(2):
var LN2_HI = 6.9313812256e-01; // 0x3f317180
var LN2_LO = 9.0580006145e-06; // 0x3717f7d1

// 2**25:
var TWO25 = 3.355443200e+07; // 0x4c000000

// 2/3:
var TWO_THIRDS = 6.666666865348816e-01;

// 2**-15:
var TWO_NEG_15 = 0x38000000;

// 2**-24:
var TWO_NEG_24 = 0x33800000;

// toWord( FLOAT32_PINF ):
var FLOAT32_PINF_WORD = 0x7f800000;

// toWord( 1.0 ):
var FLOAT32_ONE_WORD = 0x3f800000;

// toWord( 0.5 ):
var FLOAT32_HALF_WORD = 0x3f000000;


// MAIN //

/**
* Evaluates the natural logarithm of \\(1+x\\) as a single-precision floating-point number.
*
* @param {number} x - input value
* @returns {number} the natural logarithm of `1+x`
*
* @example
* var v = log1pf( 4.0 );
* // returns ~1.609
*
* @example
* var v = log1pf( -1.0 );
* // returns -Infinity
*
* @example
* var v = log1pf( 0.0 );
* // returns 0.0
*
* @example
* var v = log1pf( -0.0 );
* // returns -0.0
*
* @example
* var v = log1pf( -2.0 );
* // returns NaN
*
* @example
* var v = log1pf( NaN );
* // returns NaN
*/
function log1pf( x ) {
	var hfsq;
	var hx;
	var ax;
	var hu;
	var f;
	var c;
	var s;
	var z;
	var R;
	var u;
	var k;

	x = float64ToFloat32( x );
	hx = toWord( x ) | 0;
	ax = hx & FLOAT32_ABS_MASK;
	k = 1;
	if ( hx < 0x3ed413d0 ) { // 1+x < sqrt(2)+
		if ( ax >= 0x3f800000 ) { // x <= -1.0
			if ( x === -1.0 ) {
				return FLOAT32_NINF; // log1p(-1)=+inf
			}
			return NaN; // log1p(x<-1)=NaN
		}
		if ( ax < TWO_NEG_15 ) { // |x| < 2**-15
			if ( ( float64ToFloat32( TWO25 + x ) > 0.0 ) && ax < TWO_NEG_24 ) { // raise inexact, |x| < 2**-24
				return x;
			}
			return float64ToFloat32( x - float64ToFloat32( x * float64ToFloat32( x * 0.5 ) ) ); // eslint-disable-line max-len
		}
		if ( ( hx > 0 ) || ( hx <= 0xbe95f619 ) ) {
			// sqrt(2)/2- <= 1+x < sqrt(2)+:
			k = 0;
			f = x;
			hu = 1;
		}
	}
	if ( hx >= FLOAT32_PINF_WORD ) {
		return float64ToFloat32( x + x );
	}
	if ( k !== 0 ) {
		if ( hx < 0x5a000000 ) {
			u = float64ToFloat32( 1.0 + x );
			hu = toWord( u ) | 0;
			k = ( hu >> ( FLOAT32_PRECISION - 1 ) ) - FLOAT32_EXPONENT_BIAS;

			// Correction term:
			c = ( k > 0 ) ? float64ToFloat32( 1.0 - float64ToFloat32( u - x ) ) : float64ToFloat32( x - float64ToFloat32( u - 1.0 ) ); // eslint-disable-line max-len
			c = float64ToFloat32( c / u );
		} else {
			u = x;
			hu = toWord( u ) | 0;
			k = ( hu >> ( FLOAT32_PRECISION - 1 ) ) - FLOAT32_EXPONENT_BIAS;
			c = 0;
		}
		hu &= FLOAT32_SIGNIFICAND_MASK;

		// The approximation to sqrt(2) used in thresholds is not critical. However, the ones used above must give less strict bounds than the one here so that the k==0 case is never reached from here, since here we have committed to using the correction term but don't use it if k==0:
		if ( hu < 0x3504f4 ) { // u < sqrt(2)
			u = fromWord( ( hu | FLOAT32_ONE_WORD ) >>> 0 ); // normalize u
		} else {
			k += 1;
			u = fromWord( ( hu | FLOAT32_HALF_WORD ) >>> 0 ); // normalize u/2
			hu = ( 0x00800000 - hu ) >> 2;
		}
		f = float64ToFloat32( u - 1.0 );
	}
	hfsq = float64ToFloat32( 0.5 * float64ToFloat32( f * f ) );
	if ( hu === 0 ) { // |f| < 2**-20
		if ( f === 0.0 ) {
			if ( k === 0 ) {
				return 0.0;
			}
			c = float64ToFloat32( c + float64ToFloat32( k * LN2_LO ) );
			return float64ToFloat32( float64ToFloat32( k * LN2_HI ) + c );
		}
		R = float64ToFloat32( hfsq * float64ToFloat32( 1.0 - float64ToFloat32( TWO_THIRDS * f ) ) ); // eslint-disable-line max-len
		if ( k === 0 ) {
			return float64ToFloat32( f - R );
		}
		return float64ToFloat32( float64ToFloat32( k * LN2_HI ) - float64ToFloat32( float64ToFloat32( R - float64ToFloat32( float64ToFloat32( k * LN2_LO ) + c ) ) - f ) ); // eslint-disable-line max-len
	}
	s = float64ToFloat32( f / float64ToFloat32( 2.0 + f ) );
	z = float64ToFloat32( s * s );
	R = float64ToFloat32( z * polyval( z ) );
	if ( k === 0 ) {
		return float64ToFloat32( f - float64ToFloat32( hfsq - float64ToFloat32( s * float64ToFloat32( hfsq + R ) ) ) ); // eslint-disable-line max-len
	}
	return float64ToFloat32( float64ToFloat32( k * LN2_HI ) - float64ToFloat32( float64ToFloat32( hfsq - float64ToFloat32( float64ToFloat32( s * float64ToFloat32( hfsq + R ) ) + float64ToFloat32( float64ToFloat32( k * LN2_LO ) + c ) ) ) - f ) ); // eslint-disable-line max-len
}


// EXPORTS //

module.exports = log1pf;
