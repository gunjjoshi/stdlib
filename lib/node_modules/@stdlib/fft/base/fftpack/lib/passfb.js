/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The original C code and copyright notice are from the [PFFFT library]{@link https://github.com/marton78/pffft/blob/master/fftpack.c}. The implementation follows the original, but has been modified for JavaScript.
*
* ```text
* Copyright (c) 2004 the University Corporation for Atmospheric
* Research ("UCAR"). All rights reserved. Developed by NCAR's
* Computational and Information Systems Laboratory, UCAR,
* www.cisl.ucar.edu.
*
* Redistribution and use of the Software in source and binary forms,
* with or without modification, is permitted provided that the
* following conditions are met:
*
*     - Neither the names of NCAR's Computational and Information Systems
*       Laboratory, the University Corporation for Atmospheric Research,
*       nor the names of its sponsors or contributors may be used to
*       endorse or promote products derived from this Software without
*       specific prior written permission.
*
*     - Redistributions of source code must retain the above copyright
*       notices, this list of conditions, and the disclaimer below.
*
*     - Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions, and the disclaimer below in the
*       documentation and/or other materials provided with the
*       distribution.
*
* THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES OR OTHER LIABILITY, WHETHER IN AN
* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
* SOFTWARE.
* ```
*/

'use strict';

// MODULES //

var c1Ref = require( './c1Ref.js' );
var c2Ref = require( './c2Ref.js' );
var chRef = require( './chRef.js' );
var ch2Ref = require( './ch2Ref.js' );
var ccRef = require( './ccRef.js' );


// MAIN //

/**
* Performs a pass of the FFT algorithm.
*
* @private
* @param {Float64Array} nac - Number of FFT passes.
* @param {number} ido - Dimension order for input/output arrays.
* @param {number} ip - Number of sub-steps or prime factors in the FFT.
* @param {number} l1 - Length parameter related to the FFT stage.
* @param {number} idl1 - Stride related to the `l1` parameter.
* @param {Float64Array} cc - Input array containing complex data for FFT computation.
* @param {Float64Array} c1 - Intermediate array for FFT computations.
* @param {Float64Array} c2 - Secondary intermediate array for FFT computations.
* @param {Float64Array} ch - Output array for storing processed FFT data.
* @param {Float64Array} ch2 - Secondary output array for storing processed FFT data.
* @param {Float64Array} wa - Twiddle factor array used in FFT calculations.
* @param {number} fsign - Sign factor indicating the direction of the FFT (e.g., +1 for forward, -1 for inverse).
* @returns {void}
*/
function passfb ( nac, ido, ip, l1, idl1, cc, c1, c2, ch, ch2, wa, fsign ) {
	var ch2_offset;
	var ch_offset;
	var cc_offset;
	var c1_offset;
	var c2_offset;
	var ipp2;
	var idij;
	var idlj;
	var idot;
	var ipph;
	var idj;
	var idl;
	var inc;
	var idp;
	var wai;
	var war;
	var jc;
	var lc;
	var ik;
	var i;
	var j;
	var k;
	var l;

	// Parameter adjustments...
	ch_offset = 1 + ( ido * ( 1 + l1 ) );
	c1_offset = 1 + ( ido * ( 1 + l1 ) );
	cc_offset = 1 + ( ido * ( 1 + ip ) );
	ch2_offset = 1 + idl1;
	c2_offset = 1 + idl1;

	// Function body:
	idot = ido / 2;
	ipp2 = ip + 2;
	ipph = ( ip + 1 ) / 2;
	idp = ip * ido;
	if ( ido >= l1 ) {
		for ( j = 2; j <= ipph; ++j ) {
			jc = ipp2 - j;
			for ( k = 1; k <= l1; ++k ) {
				for ( i = 1; i <= ido; ++i ) {
					ch[ chRef( i, k, j, l1, ido ) - ch_offset ] = cc[ ccRef( i, j, k, ip, ido ) - cc_offset ] + cc[ ccRef( i, jc, k, ip, ido ) - cc_offset ]; // eslint-disable-line max-len
					ch[ chRef( i, k, jc, l1, ido ) - ch_offset ] = cc[ ccRef( i, j, k, ip, ido ) - cc_offset ] - cc[ ccRef( i, jc, k, ip, ido ) - cc_offset ]; // eslint-disable-line max-len
				}
			}
		}
		for ( k = 1; k <= l1; ++k ) {
			for ( i = 1; i <= ido; ++i ) {
				ch[ chRef( i, k, 1, l1, ido ) - ch_offset ] = cc[ ccRef( i, 1, k, ip, ido ) - cc_offset ];
			}
		}
	} else {
		for ( j = 2; j <= ipph; ++j ) {
			jc = ipp2 - j;
			for ( i = 1; i <= ido; ++i ) {
				for ( k = 1; k <= l1; ++k ) {
					ch[ chRef( i, k, j, l1, ido ) - ch_offset ] = cc[ ccRef( i, j, k, ip, ido ) - cc_offset ] + cc[ ccRef( i, jc, k, ip, ido ) - cc_offset ]; // eslint-disable-line max-len
					ch[ chRef( i, k, jc, l1, ido ) - ch_offset ] = cc[ ccRef( i, j, k, ip, ido ) - cc_offset ] - cc[ ccRef( i, jc, k, ip, ido ) - cc_offset ]; // eslint-disable-line max-len
				}
			}
		}
		for ( i = 1; i <= ido; ++i ) {
			for ( k = 1; k <= l1; ++k ) {
				ch[ chRef( i, k, 1, l1, ido ) - ch_offset ] = cc[ ccRef( i, 1, k, ip, ido ) - cc_offset ];
			}
		}
	}
	idl = 2 - ido;
	inc = 0;
	for ( l = 2; l <= ipph; ++l ) {
		lc = ipp2 - l;
		idl += ido;
		for ( ik = 1; ik <= idl1; ++ik ) {
			c2[ c2Ref( ik, l, idl1 ) - c2_offset ] = ch2[ ch2Ref( ik, 1, idl1 ) - ch2_offset ] + ( wa[ idl - 1 - 1 ] * ch2[ ch2Ref( ik, 2, idl1 ) - ch2_offset ] ); // eslint-disable-line max-len
			c2[ c2Ref( ik, lc, idl1 ) - c2_offset ] = fsign * wa[ idl - 1 ] * ch2[ ch2Ref( ik, ip, idl1 ) - ch2_offset ]; // eslint-disable-line max-len
		}
		idlj = idl;
		inc += ido;
		for ( j = 3; j <= ipph; ++j ) {
			jc = ipp2 - j;
			idlj += inc;
			if ( idlj > idp ) {
				idlj -= idp;
			}
			war = wa[ idlj - 1 - 1 ];
			wai = wa[ idlj - 1 ];
			for ( ik = 1; ik <= idl1; ++ik ) {
				c2[ c2Ref( ik, l, idl1 ) - c2_offset ] += war * ch2[ ch2Ref( ik, j, idl1 ) - ch2_offset ]; // eslint-disable-line max-len
				c2[ c2Ref( ik, lc, idl1 ) - c2_offset ] += fsign * wai * ch2[ ch2Ref( ik, jc, idl1 ) - ch2_offset ]; // eslint-disable-line max-len
			}
		}
	}
	for ( j = 2; j <= ipph; ++j ) {
		for ( ik = 1; ik <= idl1; ++ik ) {
			ch2[ ch2Ref( ik, 1, idl1 ) - ch2_offset ] += ch2[ ch2Ref( ik, j, idl1 ) - ch2_offset ]; // eslint-disable-line max-len
		}
	}
	for ( j = 2; j <= ipph; ++j ) {
		jc = ipp2 - j;
		for ( ik = 2; ik <= idl1; ik += 2 ) {
			ch2[ ch2Ref( ik - 1, j, idl1 ) - ch2_offset ] = c2[ c2Ref( ik - 1, j, idl1 ) - c2_offset ] - c2[ c2Ref( ik, jc, idl1 ) - c2_offset ]; // eslint-disable-line max-len
			ch2[ ch2Ref( ik - 1, jc, idl1 ) - ch2_offset ] = c2[ c2Ref( ik - 1, j, idl1 ) - c2_offset ] + c2[ c2Ref( ik, jc, idl1 ) - c2_offset ]; // eslint-disable-line max-len
			ch2[ ch2Ref( ik, j, idl1 ) - ch2_offset ] = c2[ c2Ref( ik, j, idl1 ) - c2_offset ] + c2[ c2Ref( ik - 1, jc, idl1 ) - c2_offset ]; // eslint-disable-line max-len
			ch2[ ch2Ref( ik, jc, idl1 ) - ch2_offset ] = c2[ c2Ref( ik, j, idl1 ) - c2_offset ] - c2[ c2Ref( ik - 1, jc, idl1 ) - c2_offset ]; // eslint-disable-line max-len
		}
	}
	nac[ 0 ] = 1;
	if ( ido === 2 ) {
		return;
	}
	nac[ 0 ] = 0;
	for ( ik = 1; ik <= idl1; ++ik ) {
		c2[ c2Ref( ik, 1, idl1 ) - c2_offset ] = ch2[ ch2Ref( ik, 1, idl1 ) - ch2_offset ];
	}
	for ( j = 2; j <= ip; ++j ) {
		for ( k = 1; k <= l1; ++k ) {
			c1[ c1Ref( 1, k, j, l1, ido ) - c1_offset ] = ch[ chRef( 1, k, j, l1, ido ) - ch_offset ];
			c1[ c1Ref( 2, k, j, l1, ido ) - c1_offset ] = ch[ chRef( 2, k, j, l1, ido ) - ch_offset ];
		}
	}
	if ( idot <= l1 ) {
		idij = 0;
		for ( j = 2; j <= ip; ++j ) {
			idij += 2;
			for ( i = 4; i <= ido; i += 2 ) {
				idij += 2;
				for ( k = 1; k <= l1; ++k ) {
					c1[ c1Ref( i - 1, k, j, l1, ido ) - c1_offset ] = ( wa[ idij - 1 - 1 ] * ch[ chRef( i - 1, k, j, l1, ido ) - ch_offset ] ) - ( fsign * wa[ idij - 1 ] * ch[ chRef( i, k, j, l1, ido ) - ch_offset ] ) ; // eslint-disable-line max-len
					c1[ c1Ref( i, k, j, l1, ido ) - c1_offset ] = ( wa[ idij - 1 ] * ch[ chRef( i, k, j, l1, ido ) - ch_offset ] ) + ( fsign * wa[ idij - 1 ] * ch[ chRef( i - 1, k, j, l1, ido ) - ch_offset ] ) ; // eslint-disable-line max-len
				}
			}
		}
		return;
	}
	idj = 2 - ido;
	for ( j = 2; j <= ip; ++j ) {
		idj += ido;
		for ( k = 1; k <= l1; ++k ) {
			idij = idj;
			for ( i = 4; i <= ido; i += 2 ) {
				idij += 2;
				c1[ c1Ref( i - 1, k, j, l1, ido ) - c1_offset ] = ( wa[ idij - 1 - 1 ] * ch[ chRef( i - 1, k, j, l1, ido ) - ch_offset ] ) - ( fsign * wa[ idij - 1 ] * ch[ chRef( i, k, j, l1, ido ) - ch_offset ] ); // eslint-disable-line max-len
				c1[ c1Ref( i, k, j, l1, ido ) - c1_offset ] = ( wa[ idij - 1 - 1 ] * ch[ chRef( i, k, j, l1, ido ) - ch_offset ] ) + ( fsign * wa[ idij - 1 ] * ch[ chRef( i - 1, k, j, l1, ido ) - ch_offset ] ); // eslint-disable-line max-len
			}
		}
	}
}


// EXPORTS //

module.exports = passfb;
