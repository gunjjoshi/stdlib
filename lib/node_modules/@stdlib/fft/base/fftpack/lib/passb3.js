/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The original C code and copyright notice are from the [PFFFT library]{@link https://github.com/marton78/pffft/blob/master/fftpack.c}. The implementation follows the original, but has been modified for JavaScript.
*
* ```text
* Copyright (c) 2004 the University Corporation for Atmospheric
* Research ("UCAR"). All rights reserved. Developed by NCAR's
* Computational and Information Systems Laboratory, UCAR,
* www.cisl.ucar.edu.
*
* Redistribution and use of the Software in source and binary forms,
* with or without modification, is permitted provided that the
* following conditions are met:
*
*     - Neither the names of NCAR's Computational and Information Systems
*       Laboratory, the University Corporation for Atmospheric Research,
*       nor the names of its sponsors or contributors may be used to
*       endorse or promote products derived from this Software without
*       specific prior written permission.
*
*     - Redistributions of source code must retain the above copyright
*       notices, this list of conditions, and the disclaimer below.
*
*     - Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions, and the disclaimer below in the
*       documentation and/or other materials provided with the
*       distribution.
*
* THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES OR OTHER LIABILITY, WHETHER IN AN
* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
* SOFTWARE.
* ```
*/

'use strict';

// MODULES //

var chRef = require( './ch_ref.js' );
var ccRef = require( './cc_ref.js' );


// VARIABLES //

var taur = 0.5;
var taui = 0.866025403784439;


// MAIN //

/**
* Performs a pass of length 3 of the FFT algorithm.
*
* @private
* @param {number} ido - Number of real values for each transform
* @param {number} l1 - Length of the input sequences
* @param {Float64Array} cc - Input array containing sequences to be transformed
* @param {Float64Array} ch - Output array containing transformed sequences
* @param {Float64Array} wa1 - First array of twiddle factors
* @param {Float64Array} wa2 - Second array of twiddle factors
* @returns {void}
*/
function passb3( ido, l1, cc, ch, wa1, wa2 ) {
	var ch_offset;
	var cc_offset;
	var ci2;
	var ci3;
	var di2;
	var di3;
	var cr2;
	var cr3;
	var dr2;
	var dr3;
	var ti2;
	var tr2;
	var i;
	var k;

	// Parameter adjustments...
	ch_offset = 1 + ( ido * ( 1 + l1 ) );
	cc_offset = 1 + ( ido << 2 );

	// Function body:
	if ( ido === 2 ) {
		for ( k = 1; k <= l1; ++k ) {
			tr2 = cc[ ccRef( 1, 2, k, 3, ido ) - cc_offset ] + cc[ ccRef( 1, 3, k, 3, ido ) - cc_offset ]; // eslint-disable-line max-len
			cr2 = cc[ ccRef( 1, 1, k, 3, ido ) - cc_offset ] + ( taur * tr2 );
			ch[ chRef( 1, k, 1, l1, ido ) - ch_offset ] = cc[ ccRef( 1, 1, k, 3, ido ) - cc_offset ] + tr2; // eslint-disable-line max-len
			ti2 = cc[ ccRef( 2, 2, k, 3, ido ) - cc_offset ] + cc[ ccRef( 2, 3, k, 3, ido ) - cc_offset ]; // eslint-disable-line max-len
			ci2 = cc[ ccRef( 2, 1, k, 3, ido ) - cc_offset ] + ( taur * ti2 );
			ch[ chRef( 2, k, 1, l1, ido ) - ch_offset ] = cc[ ccRef( 2, 1, k, 3, ido ) - cc_offset ] + ti2; // eslint-disable-line max-len
			cr3 = taui * ( cc[ ccRef( 1, 2, k, 3, ido ) - cc_offset ] - cc[ ccRef( 1, 3, k, 3, ido ) - cc_offset ] ); // eslint-disable-line max-len
			ci3 = taui * ( cc[ ccRef( 2, 2, k, 3, ido ) - cc_offset ] - cc[ ccRef( 2, 3, k, 3, ido ) - cc_offset ] ); // eslint-disable-line max-len
			ch[ chRef( 1, k, 2, l1, ido ) - ch_offset ] = cr2 - ci3;
			ch[ chRef( 1, k, 3, l1, ido ) - ch_offset ] = cr2 + ci3;
			ch[ chRef( 2, k, 2, l1, ido ) - ch_offset ] = ci2 + ci3;
			ch[ chRef( 2, k, 3, l1, ido ) - ch_offset ] = ci2 - cr3;
		}
	} else {
		for ( k = 1; k <= l1; ++k ) {
			for ( i = 2; i <= ido; i += 2 ) {
				tr2 = cc[ ccRef( i - 1, 2, k, 3, ido ) - cc_offset ] + cc[ ccRef( i - 1, 3, k, 3, ido ) - cc_offset ]; // eslint-disable-line max-len
				cr2 = cc[ ccRef( i - 1, 1, k, 3, ido ) - cc_offset ] + ( taur * tr2 );
				ch[ chRef( i - 1, k, 1, l1, ido ) - ch_offset ] = cc[ ccRef( i - 1, 1, k, 3, ido ) - cc_offset ] + tr2; // eslint-disable-line max-len
				ti2 = cc[ ccRef( i, 2, k, 3, ido ) - cc_offset ] + cc[ ccRef( i, 3, k, 3, ido ) - cc_offset ]; // eslint-disable-line max-len
				ci2 = cc[ ccRef( i, 1, k, 3, ido ) - cc_offset ] + ( taur * ti2 );
				ch[ chRef( i, k, 1, l1, ido ) - ch_offset ] = cc[ ccRef( i, 1, k, 3, ido ) - cc_offset ] + ti2; // eslint-disable-line max-len
				cr3 = taui * ( cc[ ccRef( i - 1, 2, k, 3, ido ) - cc_offset ] - cc[ ccRef( i - 1, 3, k, 3, ido ) - cc_offset ] ); // eslint-disable-line max-len
				ci3 = taui * ( cc[ ccRef( i, 2, k, 3, ido ) - cc_offset ] - cc[ ccRef( i, 3, k, 3, ido ) - cc_offset ] ); // eslint-disable-line max-len
				dr2 = cr2 - ci3;
				dr3 = cr2 + ci3;
				di2 = ci2 + ci3;
				di3 = ci2 - cr3;
				ch[ chRef( i, k, 2, l1, ido) - ch_offset ] = ( wa1[ i - 1 - 1 ] * di2 ) + ( wa1[ i - 1 ] * dr2 );
				ch[ chRef( i - 1, k, 2, l1, ido) - ch_offset ] = ( wa1[ i - 1 - 1 ] * dr2 ) - ( wa1[ i - 1 ] * di2 );
				ch[ chRef( i, k, 3, l1, ido) - ch_offset ] = ( wa2[ i - 1 - 1 ] * dr3 ) - ( wa2[ i - 1 ] * di3 );
				ch[ chRef( i - 1, k, 3, l1, ido) - ch_offset ] = ( wa2[ i - 1 - 1 ] * dr3 ) - ( wa2[ i - 1 ] * di3 );
			}
		}
	}
}


// EXPORTS //

module.exports = passb3;
